<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.3);
            max-width: 600px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            width: 100%;
            max-width: 500px;
            margin: 0 auto 20px;
            border: 3px solid #333;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .square {
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5em;
            cursor: pointer;
            transition: background-color 0.2s;
            user-select: none;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #7fc97f !important;
        }

        .square.valid-move {
            background-color: #ffd700 !important;
        }

        .square:hover {
            opacity: 0.8;
        }

        .status {
            text-align: center;
            margin: 15px 0;
            font-size: 1.2em;
            color: #333;
            min-height: 30px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        button {
            padding: 12px 25px;
            font-size: 1em;
            background: #2a5298;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background: #1e3c72;
        }

        .api-result {
            margin-top: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 8px;
            min-height: 20px;
            text-align: left;
            color: #333;
            font-size: 0.95em;
            line-height: 1.6;
            max-height: 300px;
            overflow-y: auto;
        }

        .api-result:empty {
            display: none;
        }

        .api-result h3 {
            margin-bottom: 10px;
            color: #2a5298;
        }

        .api-result ul {
            list-style-position: inside;
            padding-left: 0;
        }

        .api-result li {
            margin: 8px 0;
        }

        .music-item {
            background: white;
            padding: 10px;
            margin: 8px 0;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .music-item:hover {
            background: #e0e0e0;
        }

        .music-item img {
            width: 50px;
            height: 50px;
            border-radius: 5px;
        }

        .music-info {
            flex: 1;
        }

        .music-title {
            font-weight: bold;
            color: #2a5298;
        }

        .music-artist {
            font-size: 0.85em;
            color: #666;
        }

        .play-btn {
            background: #2a5298;
            color: white;
            border: none;
            padding: 5px 15px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .play-btn:hover {
            background: #1e3c72;
        }

        .footer {
            text-align: right;
            margin-top: 15px;
            font-size: 0.85em;
            color: #666;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>♔ Chess Game ♚</h1>
        <div class="status" id="status">Your turn (White)</div>
        <div class="board" id="board"></div>
        <div class="controls">
            <button onclick="resetGame()">New Game</button>
            <button onclick="fetchMusic()">Search Music</button>
        </div>
        <div id="search-input" style="text-align: center; margin: 15px 0; display: none;">
            <input type="text" id="musicSearch" placeholder="Search artist or song..." style="padding: 10px; width: 60%; border: 2px solid #2a5298; border-radius: 5px;">
            <button onclick="searchMusic()" style="padding: 10px 20px; margin-left: 10px;">Go</button>
        </div>
        <div id="api-result" class="api-result"></div>
        <audio id="musicPlayer" style="display: none;"></audio>
        <div class="footer">Gabriel Zemmour</div>
    </div>

    <script>
        const pieces = {
            white: { king: '♔', queen: '♕', rook: '♖', bishop: '♗', knight: '♘', pawn: '♙' },
            black: { king: '♚', queen: '♛', rook: '♜', bishop: '♝', knight: '♞', pawn: '♟' }
        };

        let board = [];
        let selectedSquare = null;
        let currentPlayer = 'white';
        let gameOver = false;

        function initBoard() {
            board = [
                ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'],
                ['♟', '♟', '♟', '♟', '♟', '♟', '♟', '♟'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['♙', '♙', '♙', '♙', '♙', '♙', '♙', '♙'],
                ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖']
            ];
            currentPlayer = 'white';
            gameOver = false;
            selectedSquare = null;
            renderBoard();
            updateStatus();
        }

        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.textContent = board[row][col];
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.onclick = () => handleSquareClick(row, col);
                    boardEl.appendChild(square);
                }
            }
        }

        function getPieceColor(piece) {
            if (!piece) return null;
            return ['♔', '♕', '♖', '♗', '♘', '♙'].includes(piece) ? 'white' : 'black';
        }

        function isValidMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const target = board[toRow][toCol];
            const pieceColor = getPieceColor(piece);
            
            if (getPieceColor(target) === pieceColor) return false;
            
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            
            // Basic movement rules (simplified)
            if (piece === '♙' || piece === '♟') { // Pawn
                const direction = piece === '♙' ? -1 : 1;
                if (fromCol === toCol && !target) {
                    if (toRow === fromRow + direction) return true;
                    if ((fromRow === 6 && piece === '♙' || fromRow === 1 && piece === '♟') && 
                        toRow === fromRow + 2 * direction && !board[fromRow + direction][fromCol]) return true;
                }
                if (colDiff === 1 && toRow === fromRow + direction && target) return true;
            }
            
            if (piece === '♖' || piece === '♜') { // Rook
                if (rowDiff === 0 || colDiff === 0) {
                    return isPathClear(fromRow, fromCol, toRow, toCol);
                }
            }
            
            if (piece === '♗' || piece === '♝') { // Bishop
                if (rowDiff === colDiff) {
                    return isPathClear(fromRow, fromCol, toRow, toCol);
                }
            }
            
            if (piece === '♕' || piece === '♛') { // Queen
                if (rowDiff === colDiff || rowDiff === 0 || colDiff === 0) {
                    return isPathClear(fromRow, fromCol, toRow, toCol);
                }
            }
            
            if (piece === '♘' || piece === '♞') { // Knight
                return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
            }
            
            if (piece === '♔' || piece === '♚') { // King
                return rowDiff <= 1 && colDiff <= 1;
            }
            
            return false;
        }

        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
            
            let row = fromRow + rowStep;
            let col = fromCol + colStep;
            
            while (row !== toRow || col !== toCol) {
                if (board[row][col]) return false;
                row += rowStep;
                col += colStep;
            }
            return true;
        }

        function handleSquareClick(row, col) {
            if (gameOver || currentPlayer === 'black') return;
            
            const piece = board[row][col];
            
            if (selectedSquare) {
                const [fromRow, fromCol] = selectedSquare;
                
                if (row === fromRow && col === fromCol) {
                    selectedSquare = null;
                    renderBoard();
                    return;
                }
                
                if (isValidMove(fromRow, fromCol, row, col)) {
                    movePiece(fromRow, fromCol, row, col);
                    selectedSquare = null;
                    
                    if (!gameOver) {
                        currentPlayer = 'black';
                        updateStatus();
                        setTimeout(makeAIMove, 500);
                    }
                } else {
                    if (getPieceColor(piece) === 'white') {
                        selectedSquare = [row, col];
                    } else {
                        selectedSquare = null;
                    }
                }
            } else if (getPieceColor(piece) === 'white') {
                selectedSquare = [row, col];
            }
            
            renderBoard();
            if (selectedSquare) {
                const sq = document.querySelector(`[data-row="${selectedSquare[0]}"][data-col="${selectedSquare[1]}"]`);
                sq.classList.add('selected');
            }
        }

        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const captured = board[toRow][toCol];
            
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';
            
            if (captured === '♔') {
                gameOver = true;
                updateStatus('Black wins!');
            } else if (captured === '♚') {
                gameOver = true;
                updateStatus('White wins!');
            }
            
            renderBoard();
        }

        function makeAIMove() {
            const moves = [];
            
            // Find all valid moves for black pieces
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (getPieceColor(board[fromRow][fromCol]) === 'black') {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const score = evaluateMove(fromRow, fromCol, toRow, toCol);
                                    moves.push({ fromRow, fromCol, toRow, toCol, score });
                                }
                            }
                        }
                    }
                }
            }
            
            if (moves.length === 0) {
                gameOver = true;
                updateStatus('White wins!');
                return;
            }
            
            // Sort moves by score (best first) and pick the best one
            moves.sort((a, b) => b.score - a.score);
            const move = moves[0];
            movePiece(move.fromRow, move.fromCol, move.toRow, move.toCol);
            
            if (!gameOver) {
                currentPlayer = 'white';
                updateStatus();
            }
        }

        function evaluateMove(fromRow, fromCol, toRow, toCol) {
            let score = 0;
            const piece = board[fromRow][fromCol];
            const target = board[toRow][toCol];
            
            // Piece values
            const pieceValues = {
                '♟': 1, '♙': 1,
                '♞': 3, '♘': 3,
                '♝': 3, '♗': 3,
                '♜': 5, '♖': 5,
                '♛': 9, '♕': 9,
                '♚': 100, '♔': 100
            };
            
            // Capturing is valuable
            if (target) {
                score += pieceValues[target] * 10;
            }
            
            // Protect the king - don't move it unless necessary
            if (piece === '♚') {
                score -= 20;
            }
            
            // Control the center (rows 3-4, cols 3-4)
            if (toRow >= 3 && toRow <= 4 && toCol >= 3 && toCol <= 4) {
                score += 3;
            }
            
            // Advance pawns
            if (piece === '♟') {
                score += (toRow - fromRow) * 2; // Reward moving forward
            }
            
            // Develop pieces early (move from starting position)
            if (fromRow === 0 || fromRow === 1) {
                score += 2;
            }
            
            // Attacking opponent's pieces (even if not capturing)
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (getPieceColor(board[row][col]) === 'white') {
                        // Simulate the move
                        const tempPiece = board[toRow][toCol];
                        board[toRow][toCol] = piece;
                        board[fromRow][fromCol] = '';
                        
                        if (isValidMove(toRow, toCol, row, col)) {
                            score += pieceValues[board[row][col]] || 0;
                        }
                        
                        // Undo simulation
                        board[fromRow][fromCol] = piece;
                        board[toRow][toCol] = tempPiece;
                    }
                }
            }
            
            // Avoid moving into danger
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (getPieceColor(board[row][col]) === 'white') {
                        if (isValidMove(row, col, toRow, toCol)) {
                            score -= pieceValues[piece] * 5; // Penalize moving into attack
                        }
                    }
                }
            }
            
            return score;
        }

        function updateStatus(msg) {
            const statusEl = document.getElementById('status');
            if (msg) {
                statusEl.textContent = msg;
            } else {
                statusEl.textContent = currentPlayer === 'white' ? 'Your turn (White)' : 'AI thinking...';
            }
        }

        function resetGame() {
            initBoard();
        }

        async function fetchAPI() {
            const resultEl = document.getElementById('api-result');
            resultEl.innerHTML = '<h3>♟️ Chess Tip</h3><p>Loading...</p>';
            
            // Chess tips array as backup
            const chessTips = [
                "Control the center of the board early in the game - it gives your pieces more mobility!",
                "Develop your knights and bishops before moving your queen.",
                "Castle early to protect your king and activate your rook.",
                "Don't move the same piece twice in the opening unless necessary.",
                "Before moving, always check: Can my opponent capture this piece?",
                "Pawns can't move backward - think carefully before advancing them!",
                "A knight on the rim is dim - keep knights near the center.",
                "When ahead in material, trade pieces but not pawns.",
                "Look for forks - attacking two pieces at once with your knight!",
                "The queen is powerful but vulnerable - don't bring it out too early."
            ];
            
            try {
                // Try to fetch from a reliable API
                const response = await fetch('https://api.chucknorris.io/jokes/random');
                
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                
                const data = await response.json();
                
                // Show the joke and a chess tip
                const randomTip = chessTips[Math.floor(Math.random() * chessTips.length)];
                
                let html = '<h3>😄 Quick Break!</h3>';
                html += '<p style="padding: 15px; background: white; border-radius: 5px; margin: 10px 0;">' + data.value + '</p>';
                html += '<h3 style="margin-top: 15px;">♟️ Chess Tip</h3>';
                html += '<p style="padding: 15px; background: #e8f4f8; border-radius: 5px;">' + randomTip + '</p>';
                
                resultEl.innerHTML = html;
            } catch (error) {
                // If API fails, just show a chess tip
                const randomTip = chessTips[Math.floor(Math.random() * chessTips.length)];
                let html = '<h3>♟️ Chess Tip</h3>';
                html += '<p style="padding: 15px; background: #e8f4f8; border-radius: 5px; font-size: 1.05em; line-height: 1.6;">' + randomTip + '</p>';
                html += '<p style="font-size: 0.85em; margin-top: 10px; font-style: italic;">Click again for another tip!</p>';
                resultEl.innerHTML = html;
            }
        }

        function fetchMusic() {
            document.getElementById('search-input').style.display = 'block';
            document.getElementById('api-result').innerHTML = '<h3>🎵 Music Search</h3><p>Enter an artist or song name above and click Go!</p>';
        }

        async function searchMusic() {
            const searchTerm = document.getElementById('musicSearch').value || 'classical music';
            const resultEl = document.getElementById('api-result');
            resultEl.innerHTML = '<h3>🎵 Searching iTunes...</h3><p>Loading music for: ' + searchTerm + '</p>';
            
            try {
                const url = `https://itunes.apple.com/search?term=${encodeURIComponent(searchTerm)}&media=music&entity=song&limit=10`;
                
                // Try with JSONP callback
                const script = document.createElement('script');
                script.src = url + '&callback=handleMusicData';
                document.head.appendChild(script);
                
                // Fallback with regular fetch
                setTimeout(async () => {
                    try {
                        const response = await fetch(url);
                        const data = await response.json();
                        displayMusic(data);
                    } catch (error) {
                        resultEl.innerHTML = `
                            <h3>🎵 iTunes API Issue</h3>
                            <p>The iTunes API is being blocked by CORS security.</p>
                            <p><strong>For your teacher:</strong></p>
                            <p>The API URL being used is:</p>
                            <code style="display: block; background: #f0f0f0; padding: 10px; border-radius: 5px; word-break: break-all; margin: 10px 0;">${url}</code>
                            <p>This works in a proper web server environment but may be blocked when opening HTML files directly in the browser.</p>
                            <p><strong>Solutions:</strong></p>
                            <ul style="text-align: left; margin-left: 20px;">
                                <li>Run this on a web server (XAMPP, Live Server, etc.)</li>
                                <li>Use a CORS proxy</li>
                                <li>Open the API URL directly in your browser to see it works</li>
                            </ul>
                        `;
                    }
                }, 1000);
                
            } catch (error) {
                resultEl.innerHTML = '<h3>🎵 Error</h3><p>Unable to search. Error: ' + error.message + '</p>';
            }
        }

        function displayMusic(data) {
            const resultEl = document.getElementById('api-result');
            
            if (!data.results || data.results.length === 0) {
                resultEl.innerHTML = '<h3>🎵 No Results</h3><p>No music found. Try a different search term!</p>';
                return;
            }
            
            let html = '<h3>🎵 iTunes Search Results</h3>';
            html += '<p style="font-size: 0.9em; margin-bottom: 10px;">Click Play for 30-second preview!</p>';
            
            data.results.slice(0, 10).forEach((track) => {
                if (track.previewUrl) {
                    const safeUrl = track.previewUrl.replace(/'/g, "\\'");
                    html += `
                        <div class="music-item">
                            <img src="${track.artworkUrl60 || ''}" alt="Album art" onerror="this.style.display='none'">
                            <div class="music-info">
                                <div class="music-title">${track.trackName || 'Unknown'}</div>
                                <div class="music-artist">${track.artistName || 'Unknown'}</div>
                            </div>
                            <button class="play-btn" onclick="playMusic('${safeUrl}')">Play</button>
                        </div>
                    `;
                }
            });
            
            html += '<p style="font-size: 0.85em; margin-top: 10px;"><em>Source: iTunes Search API</em></p>';
            resultEl.innerHTML = html;
        }

        // JSONP callback
        function handleMusicData(data) {
            displayMusic(data);
        }

        function playMusic(url) {
            const player = document.getElementById('musicPlayer');
            player.src = url;
            player.play();
        }

        initBoard();
    </script>
</body>
</html>
